{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport React, { PureComponent } from 'react';\nimport withAntmedia from 'src/antmedia';\nimport { Button, message } from 'antd';\nimport Router from 'next/router';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport { SocketContext } from 'src/socket';\nimport { streamService } from 'src/services';\nimport videojs from 'video.js';\nimport './private-streaming-container.less';\nconst STREAM_JOINED = 'private-stream/streamJoined';\nconst STREAM_LEAVED = 'private-stream/streamLeaved';\nconst JOINED_THE_ROOM = 'JOINED_THE_ROOM';\n\nclass PrivateStreamingContainer extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"activeStreams\", []);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"getLiveStreamOrVodURLInterval\", void 0);\n\n    this.state = {\n      sessionId: '',\n      // roomName\n      streamId: '',\n      streamList: [],\n      conversationId: '',\n      loading: false,\n      newAvailableStreams: []\n    };\n  }\n\n  componentDidMount() {\n    this.socket = this.context;\n  }\n\n  componentDidUpdate(prevProps, prevStates) {\n    const {\n      processing,\n      initialized\n    } = this.props;\n    const {\n      conversationId,\n      newAvailableStreams\n    } = this.state;\n\n    if (prevProps.processing !== processing) {\n      this.handleLoading(processing);\n    }\n\n    if (conversationId && conversationId !== prevStates.conversationId) {\n      this.initSocketEvent();\n    }\n\n    if (initialized && newAvailableStreams.length) {\n      newAvailableStreams.forEach(streamId => {\n        this.play(streamId);\n      }); // eslint-disable-next-line react/no-did-update-set-state\n\n      this.setState({\n        newAvailableStreams: []\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.onbeforeunload.bind(this));\n    Router.events.off('routeChangeStart', this.onbeforeunload.bind(this));\n  }\n\n  handleLoading(v) {\n    this.setState({\n      loading: v\n    });\n  }\n\n  async onHandlePrivateStream(info, obj) {\n    const {\n      sessionId,\n      conversationId,\n      streamId\n    } = this.state;\n    const {\n      settings,\n      webRTCAdaptor\n    } = this.props;\n    this.socket = this.context;\n\n    if (info === 'initialized') {\n      if (settings.optionForPrivate === 'hls') {\n        const token = await streamService.getPublishToken({\n          streamId,\n          settings\n        });\n        webRTCAdaptor.publish(streamId, token);\n      }\n\n      webRTCAdaptor.joinRoom(conversationId, streamId);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      const activeStream = this.activeStreams.find(id => id === obj.streamId);\n\n      if (!activeStream) {\n        this.activeStreams.push(obj.streamId);\n        this.createRemoteVideo(obj.stream);\n      }\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.JOINED_THE_ROOM) {\n      if (settings.optionForPrivate === 'webrtc') {\n        const token = await streamService.getPublishToken({\n          streamId,\n          settings\n        });\n        webRTCAdaptor.publish(streamId, token);\n      }\n    } else if (info === 'publish_started') {\n      this.socket.emit('private-stream/join', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n      this.setState({\n        loading: false\n      });\n    } else if (info === 'publish_finished') {\n      this.socket.emit('private-stream/leave', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n      this.setState({\n        loading: false\n      });\n    }\n  }\n\n  onbeforeunload() {\n    this.leaveStream();\n  }\n\n  initSocketEvent() {\n    const {\n      initWebRTCAdaptor,\n      settings,\n      role_data,\n      performer\n    } = this.props;\n    this.socket = this.context;\n    this.socket.on(JOINED_THE_ROOM, ({\n      streamId,\n      streamList,\n      conversationId: _id\n    }) => {\n      const {\n        conversationId,\n        newAvailableStreams\n      } = this.state;\n      if (_id !== conversationId) return;\n      this.setState({\n        streamId,\n        streamList\n      });\n      initWebRTCAdaptor(this.onHandlePrivateStream.bind(this));\n\n      if (window['videojs'] && streamList.length) {\n        settings.optionForPrivate === 'webrtc' ? this.setState({\n          newAvailableStreams: [...newAvailableStreams, streamList[0]]\n        }) : this.subscribeHLS(streamList[0]);\n      }\n    });\n    this.socket.on(STREAM_JOINED, data => {\n      const {\n        streamId,\n        newAvailableStreams\n      } = this.state;\n\n      if (window['videojs'] && streamId !== data.streamId) {\n        settings.optionForPrivate === 'webrtc' ? this.setState({\n          newAvailableStreams: [...newAvailableStreams, data.streamId]\n        }) : this.subscribeHLS(data.streamId);\n      }\n    });\n    this.socket.on(STREAM_LEAVED, data => {\n      const {\n        streamList\n      } = this.state;\n      this.setState({\n        streamList: streamList.filter(id => id !== data.streamId)\n      });\n      window['mainPlayer'] && window['mainPlayer'].dispose();\n      this.activeStreams = this.activeStreams.filter(id => id !== data.streamId);\n      this.removeRemoteVideo();\n      message.error('Private call has ended.');\n      window.setTimeout(() => {\n        if (role_data === 'performer') {\n          Router.push('/live');\n        } else if (role_data === 'user') {\n          Router.push({\n            pathname: '/stream',\n            query: {\n              performer: JSON.stringify(performer)\n            }\n          }, `/profile/${performer.username}`);\n        } else {\n          Router.push('/');\n        }\n      }, 1000);\n    });\n    Router.events.on('routeChangeStart', this.onbeforeunload.bind(this));\n    window.addEventListener('beforeunload', this.onbeforeunload.bind(this));\n  }\n\n  start(sessionId, conversationId) {\n    this.setState({\n      sessionId,\n      conversationId\n    });\n  }\n\n  leaveStream() {\n    const {\n      publish_started,\n      webRTCAdaptor\n    } = this.props;\n    const {\n      sessionId,\n      conversationId,\n      streamId\n    } = this.state;\n    this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n    this.socket.off(JOINED_THE_ROOM);\n    this.socket.off(STREAM_JOINED);\n    this.socket.off(STREAM_LEAVED);\n\n    if (publish_started) {\n      webRTCAdaptor && webRTCAdaptor.leaveFromRoom(conversationId);\n      this.socket.emit('private-stream/leave', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n    }\n  }\n\n  async ended(streamId) {\n    const {\n      settings\n    } = this.props;\n    const src = await streamService.getLiveStreamOrVodURL({\n      streamId,\n      settings,\n      appName: settings.AntMediaAppname\n    });\n\n    if (src) {\n      this.getLiveStreamOrVodURLInterval = setInterval(() => {\n        fetch(src, {\n          method: 'GET'\n        }).then(() => {\n          this.subscribeHLS(streamId);\n          this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n        });\n      }, 5000);\n    }\n  }\n\n  async subscribeHLS(streamId) {\n    const {\n      settings,\n      configs\n    } = this.props;\n    const appName = configs.appName || settings.AntMediaAppname;\n    this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n    const src = await streamService.getLiveStreamOrVodURL({\n      appName,\n      settings,\n      streamId\n    });\n\n    if (!src) {\n      return;\n    }\n\n    let video = document.querySelector('#private-subscriber');\n\n    if (!video) {\n      video = document.createElement('video');\n      video.setAttribute('id', 'private-subscriber');\n      video.setAttribute('class', 'video-js vjs-waiting');\n      video.setAttribute('autoplay', 'autoplay');\n      video.setAttribute('data-setup', '{\"fluid\": true}');\n      document.querySelector('.private-streaming-container').append(video);\n    }\n\n    if (!window['mainPlayer']) {\n      window['mainPlayer'] = videojs('private-subscriber', {\n        liveui: true,\n        controls: true\n      });\n      window['mainPlayer'].on('ended', () => this.ended(streamId));\n      window['mainPlayer'].on('error', () => this.ended(streamId));\n    }\n\n    setTimeout(() => {\n      if (!window['mainPlayer']) return;\n      window['mainPlayer'].src({\n        type: 'application/x-mpegURL',\n        src\n      });\n      window['mainPlayer'].play();\n    }, 10 * 1000);\n  }\n\n  createRemoteVideo(stream) {\n    const video = document.createElement('video');\n    video.setAttribute('id', 'private-subscriber');\n    video.setAttribute('class', 'video-js');\n    video.setAttribute('autoplay', 'autoplay');\n    video.setAttribute('controls', 'controls');\n    video.srcObject = stream;\n    document.querySelector('.private-streaming-container').append(video); // video.oncanplay = (() => {\n    //   window['player'] = videojs('private-subscriber', {\n    //     liveui: true,\n    //     controls: true\n    //   });\n    // });\n  }\n\n  removeRemoteVideo() {\n    const video = document.getElementById('private-subscriber');\n\n    if (video) {\n      video.srcObject = null; // window['player'] && window['player'].dispose();\n\n      document.querySelector('.private-streaming-container').removeChild(video);\n    }\n  }\n\n  leave() {\n    if (false) {\n      window.location.reload();\n    }\n  }\n\n  stop() {\n    const {\n      leaveSession\n    } = this.props;\n    leaveSession();\n  }\n\n  async play(streamId) {\n    const {\n      settings,\n      webRTCAdaptor\n    } = this.props;\n    const token = await streamService.getSubscriberToken({\n      streamId,\n      settings\n    });\n    webRTCAdaptor.play(streamId, token);\n  }\n\n  render() {\n    const {\n      onClick,\n      btnText,\n      initialized\n    } = this.props;\n    const {\n      loading\n    } = this.state;\n    return __jsx(\"div\", {\n      className: \"private-streaming-container\"\n    }, __jsx(\"video\", {\n      id: \"private-publisher\",\n      autoPlay: true,\n      muted: true,\n      playsInline: true\n    }), !initialized ? __jsx(Button, {\n      type: \"primary\",\n      onClick: () => onClick(),\n      loading: loading,\n      block: true\n    }, btnText || 'Start Streaming') : __jsx(Button, {\n      type: \"primary\",\n      onClick: this.leave.bind(this),\n      block: true,\n      disabled: loading\n    }, \"Stop Streaming\"));\n  }\n\n}\n\nPrivateStreamingContainer.contextType = SocketContext;\nexport default withAntmedia(PrivateStreamingContainer);","map":null,"metadata":{},"sourceType":"module"}