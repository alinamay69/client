{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport * as React from 'react';\nimport classnames from 'classnames';\nimport fetch from 'isomorphic-unfetch';\nimport withAntMedia from 'src/antmedia';\nimport { streamService } from 'src/services';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport videojs from 'video.js';\nimport './index.less';\nconst DEFAULT_OFFLINE_IMAGE_URL = '/offline.png';\n\nclass Subscriber extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"streamId\", void 0);\n\n    _defineProperty(this, \"activeStreams\", []);\n\n    _defineProperty(this, \"getLiveStreamOrVodURLInterval\", void 0);\n  }\n\n  componentDidMount() {\n    window['player'] = videojs('subscriber', {\n      autoplay: true,\n      liveui: true,\n      controls: true,\n      controlBar: {\n        volumePanel: {\n          inline: false\n        }\n      }\n    });\n    window['player'].error(null);\n    window['player'].on('ended', this.ended.bind(this));\n    window['player'].on('error', this.ended.bind(this));\n  }\n\n  componentWillUnmount() {\n    this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n    window['player'] && window['player'].dispose();\n  }\n\n  async handler(info, obj) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamId,\n        settings\n      });\n      webRTCAdaptor.play(this.streamId, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      const activeStream = this.activeStreams.find(id => id === obj.streamId);\n\n      if (window['player']) {\n        window['player'].dispose();\n        window['player'] = undefined;\n      }\n\n      if (!activeStream) {\n        this.activeStreams.push(obj.streamId);\n        this.createRemoteVideo(obj.stream);\n      }\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.activeStreams = this.activeStreams.filter(id => id !== obj.streamId);\n      this.removeRemoteVideo();\n\n      if (!window['player']) {\n        this.createPlaybackideo();\n        window['player'].poster(settings.defaultOfflineModelImage || DEFAULT_OFFLINE_IMAGE_URL);\n      }\n\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 3000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (obj.streamId === this.streamId) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  createPlaybackideo() {\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', 'video-js');\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    document.querySelector('.video-container').append(video);\n    window['player'] = videojs('subscriber', {\n      autoplay: true,\n      liveui: true,\n      controls: true,\n      controlBar: {\n        volumePanel: {\n          inline: false\n        }\n      }\n    });\n    window['player'].on('ended', this.ended.bind(this));\n    window['player'].on('error', this.ended.bind(this));\n    window['player'].controls(false);\n  }\n\n  resetPlaybackVideo() {\n    var _window$player;\n\n    this.streamId = '';\n\n    if ((_window$player = window['player']) !== null && _window$player !== void 0 && _window$player.src()) {\n      window['player'].dispose();\n      window['player'] = undefined;\n      this.createPlaybackideo();\n    }\n  }\n\n  async cbErrorHandler(error) {\n    if (error === 'no_stream_exist') {\n      const {\n        webRTCAdaptor,\n        initWebRTCAdaptor\n      } = this.props;\n\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n      } else {\n        this.streamId && webRTCAdaptor.getStreamInfo(this.streamId);\n      }\n    }\n  }\n\n  async ended() {\n    window['player'] && window['player'].error(null);\n    const {\n      settings\n    } = this.props;\n\n    if (!this.streamId) {\n      return;\n    }\n\n    const src = await streamService.getLiveStreamOrVodURL({\n      streamId: this.streamId,\n      settings,\n      appName: settings.AntMediaAppname\n    });\n\n    if (src) {\n      this.getLiveStreamOrVodURLInterval = setInterval(() => {\n        fetch(src, {\n          method: 'HEAD'\n        }).then(() => {\n          this.playHLS(this.streamId);\n          this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n        });\n      }, 5000);\n    }\n  }\n\n  createRemoteVideo(stream) {\n    const video = document.createElement('video');\n    video.setAttribute('id', 'subscriber');\n    video.setAttribute('class', 'video-js');\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    video.srcObject = stream;\n    document.querySelector('.video-container').append(video);\n  }\n\n  removeRemoteVideo() {\n    const video = document.getElementById('subscriber');\n\n    if (video) {\n      video.srcObject = null;\n      document.querySelector('.video-container').removeChild(video);\n    }\n  }\n\n  async play(streamId) {\n    const {\n      initWebRTCAdaptor,\n      initialized,\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    this.streamId = streamId;\n\n    if (initialized) {\n      const token = await streamService.getSubscriberToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.play(streamId, token);\n      return;\n    }\n\n    initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n  }\n\n  async playHLS(streamId) {\n    const {\n      configs,\n      settings\n    } = this.props;\n    const appName = configs.appName || settings.AntMediaAppname;\n    this.streamId = streamId;\n    this.getLiveStreamOrVodURLInterval && clearInterval(this.getLiveStreamOrVodURLInterval);\n    const src = await streamService.getLiveStreamOrVodURL({\n      appName,\n      settings,\n      streamId\n    });\n\n    if (!src) {\n      return;\n    }\n\n    if (!window['player']) {\n      window['player'] = videojs('subscriber', {\n        autoplay: true,\n        liveui: true,\n        controls: true,\n        controlBar: {\n          volumePanel: {\n            inline: false\n          }\n        }\n      });\n      window['player'].on('ended', this.ended.bind(this));\n      window['player'].on('error', this.ended.bind(this));\n    } // window['player'].addClass('vjs-waiting');\n\n\n    setTimeout(() => {\n      if (!window['player']) return;\n      window['player'].src({\n        type: 'application/x-mpegURL',\n        src\n      });\n      window['player'].play();\n      window['player'].controls(true);\n    }, 1 * 1000);\n  }\n\n  stop() {\n    this.streamId = '';\n  }\n\n  render() {\n    const {\n      classNames\n    } = this.props;\n    const videoProps = {\n      id: 'subscriber',\n      controls: true,\n      className: classnames('video-js', classNames),\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      width: '100%'\n    };\n    return __jsx(\"div\", {\n      className: \"video-container\"\n    }, __jsx(\"video\", videoProps));\n  }\n\n}\n\nexport default withAntMedia(Subscriber);","map":null,"metadata":{},"sourceType":"module"}