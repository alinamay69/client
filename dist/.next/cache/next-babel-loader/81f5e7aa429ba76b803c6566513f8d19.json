{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { PureComponent } from 'react';\nimport PerformerGrid from '@components/performer/performer-grid';\nimport { connect } from 'react-redux';\nimport { loginSuccess } from '@redux/auth/actions';\nimport { updateCurrentUser } from '@redux/user/actions';\nimport { updateCurrentStudio } from '@redux/studio/actions';\nimport { favouriteService } from 'src/services';\nimport { message } from 'antd';\nimport { getResponseError } from '@lib/utils';\nimport Router, { withRouter } from 'next/router';\nimport { getBanners } from '@redux/banner/actions';\nimport { createSelector } from 'reselect';\nimport { SocketContext } from 'src/socket';\nimport Head from 'next/head';\nimport { camAggregatorService } from '@services/cam-aggregator.service';\nimport AggregatorFilter from '@components/cam-aggregator/aggregator-filter';\nimport AggregatorProfileGridCard from '@components/cam-aggregator/grid-card';\nimport Loader from '@components/common/base/loader';\nconst initQueryState = {\n  offset: 0,\n  limit: 60,\n  gender: '',\n  category: '',\n  country: '',\n  sortBy: '',\n  sort: 'desc',\n  q: ''\n};\n\nclass CamAggregator extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"search\", async params => {\n      const {\n        query\n      } = this.state;\n\n      try {\n        await this.setState({\n          loading: true\n        });\n        const resp = await camAggregatorService.online(_objectSpread(_objectSpread({}, query), params || {}));\n        this.setState({\n          performers: resp.data.data,\n          total: resp.data.count\n        });\n      } catch (error) {\n        const err = await Promise.resolve(error);\n        message.error(getResponseError(err));\n      } finally {\n        this.setState({\n          loading: false\n        });\n      }\n    });\n\n    this.state = {\n      query: initQueryState,\n      loading: true\n    };\n  }\n\n  async componentDidMount() {\n    var _router$query, _router$query2;\n\n    const {\n      router\n    } = this.props;\n    this.search({\n      tag: ((_router$query = router.query) === null || _router$query === void 0 ? void 0 : _router$query.tag) || '',\n      q: ((_router$query2 = router.query) === null || _router$query2 === void 0 ? void 0 : _router$query2.q) || ''\n    });\n    this.getCamAggregatorCategories();\n  }\n\n  componentDidUpdate(prevProps, prevStates) {\n    const {\n      router\n    } = this.props;\n    const {\n      query\n    } = this.state;\n\n    if (router.query.q !== prevProps.router.query.q || query !== prevStates.query) {\n      var _router$query3, _router$query4;\n\n      const q = {\n        tag: ((_router$query3 = router.query) === null || _router$query3 === void 0 ? void 0 : _router$query3.tag) || '',\n        q: ((_router$query4 = router.query) === null || _router$query4 === void 0 ? void 0 : _router$query4.q) || ''\n      };\n      if (router.query.q !== prevProps.router.query.q) q.offset = 0;\n      this.search(q);\n    }\n\n    if (router.query.category !== prevProps.router.query.category) {\n      this.setQuery('category', router.query.category || '');\n    }\n  }\n\n  async onLike(performer) {\n    const {\n      updatePerformerFavourite: dispatchUpdatePerformerFavorite\n    } = this.props;\n    const {\n      _id,\n      isFavorite\n    } = performer;\n\n    try {\n      await favouriteService.favorite(_id, isFavorite);\n      dispatchUpdatePerformerFavorite(_id);\n    } catch (error) {\n      const e = await Promise.resolve(error);\n      message.error(getResponseError(e));\n    }\n  }\n\n  setFilter(name, value) {\n    const {\n      query\n    } = this.state;\n\n    if (name === 'category' && value !== query.category) {\n      Router.push({\n        pathname: '/cams',\n        query: {\n          category: value\n        }\n      }, `/cams?category=${value}`);\n      return;\n    }\n\n    this.setState({\n      query: _objectSpread(_objectSpread({}, query), {}, {\n        [name]: value\n      })\n    });\n  }\n\n  setQuery(name, value) {\n    const {\n      query\n    } = this.state;\n    this.setState({\n      query: _objectSpread(_objectSpread({}, query), {}, {\n        [name]: value\n      })\n    });\n  }\n\n  async getCamAggregatorCategories() {\n    const resp = await camAggregatorService.categories({});\n    await this.setState({\n      categories: resp.data\n    });\n  }\n\n  clearFilter() {\n    this.setState({\n      query: initQueryState\n    });\n  }\n\n  render() {\n    const {\n      ui,\n      countries\n    } = this.props;\n    const {\n      query,\n      performers = [],\n      categories,\n      total,\n      loading\n    } = this.state;\n    return __jsx(React.Fragment, null, __jsx(Head, null, __jsx(\"title\", null, ui === null || ui === void 0 ? void 0 : ui.siteName, ' ', \"| Cams\")), __jsx(\"div\", {\n      className: \"homepage\"\n    }, __jsx(AggregatorFilter, _extends({\n      categories: categories,\n      countries: countries,\n      setFilter: this.setFilter.bind(this),\n      clearFilter: this.clearFilter.bind(this)\n    }, query)), __jsx(Loader, {\n      spinning: loading,\n      fullScreen: true\n    }), __jsx(PerformerGrid, _extends({}, this.props, {\n      data: performers,\n      total: total,\n      success: true,\n      onLike: this.onLike.bind(this),\n      title: \"Live cams\",\n      isPage: true,\n      setFilter: this.setFilter.bind(this),\n      gridCard: AggregatorProfileGridCard\n    }, query))));\n  }\n\n}\n\n_defineProperty(CamAggregator, \"layout\", 'public');\n\n_defineProperty(CamAggregator, \"authenticate\", false);\n\nconst bannerSelecter = state => state.banner.listBanners.data;\n\nconst filterBanner = createSelector(bannerSelecter, banners => {\n  if (!banners.length) return {};\n  return {\n    topBanners: banners.filter(b => b.position === 'top'),\n    rightBanners: banners.filter(b => b.position === 'right'),\n    bottomBanners: banners.filter(b => b.position === 'bottom')\n  };\n});\nCamAggregator.contextType = SocketContext;\n\nconst mapStateToProps = state => _objectSpread(_objectSpread({\n  ui: _objectSpread({}, state.ui)\n}, state.performer.performers), {}, {\n  banners: filterBanner(state),\n  countries: state.settings.countries,\n  loggedIn: state.auth.loggedIn // categories: state.performer.categories.data\n\n});\n\nconst mapDispatch = {\n  getBanners,\n  updateCurrentUser,\n  updateCurrentStudio,\n  loginSuccess\n};\nexport default connect(mapStateToProps, mapDispatch)(withRouter(CamAggregator));","map":{"version":3,"sources":["/Users/frag-games/Desktop/Test Projects/secret-client/pages/cams/index.tsx"],"names":["React","PureComponent","PerformerGrid","connect","loginSuccess","updateCurrentUser","updateCurrentStudio","favouriteService","message","getResponseError","Router","withRouter","getBanners","createSelector","SocketContext","Head","camAggregatorService","AggregatorFilter","AggregatorProfileGridCard","Loader","initQueryState","offset","limit","gender","category","country","sortBy","sort","q","CamAggregator","constructor","props","params","query","state","setState","loading","resp","online","performers","data","total","count","error","err","Promise","resolve","componentDidMount","router","search","tag","getCamAggregatorCategories","componentDidUpdate","prevProps","prevStates","setQuery","onLike","performer","updatePerformerFavourite","dispatchUpdatePerformerFavorite","_id","isFavorite","favorite","e","setFilter","name","value","push","pathname","categories","clearFilter","render","ui","countries","siteName","bind","bannerSelecter","banner","listBanners","filterBanner","banners","length","topBanners","filter","b","position","rightBanners","bottomBanners","contextType","mapStateToProps","settings","loggedIn","auth","mapDispatch"],"mappings":";;;;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,aAAhB,QAAqC,OAArC;AAOA,OAAOC,aAAP,MAA0B,sCAA1B;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,YAAT,QAA6B,qBAA7B;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,SAASC,gBAAT,QAAiC,cAAjC;AACA,SAASC,OAAT,QAAwB,MAAxB;AACA,SAASC,gBAAT,QAAiC,YAAjC;AACA,OAAOC,MAAP,IAAiBC,UAAjB,QAA+C,aAA/C;AACA,SAASC,UAAT,QAA2B,uBAA3B;AACA,SAASC,cAAT,QAA+B,UAA/B;AACA,SAASC,aAAT,QAA8B,YAA9B;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,SAASC,oBAAT,QAAqC,kCAArC;AAEA,OAAOC,gBAAP,MAA6B,8CAA7B;AACA,OAAOC,yBAAP,MAAsC,sCAAtC;AACA,OAAOC,MAAP,MAAmB,gCAAnB;AAsCA,MAAMC,cAA8B,GAAG;AACrCC,EAAAA,MAAM,EAAE,CAD6B;AAErCC,EAAAA,KAAK,EAAE,EAF8B;AAGrCC,EAAAA,MAAM,EAAE,EAH6B;AAIrCC,EAAAA,QAAQ,EAAE,EAJ2B;AAKrCC,EAAAA,OAAO,EAAE,EAL4B;AAMrCC,EAAAA,MAAM,EAAE,EAN6B;AAOrCC,EAAAA,IAAI,EAAE,MAP+B;AAQrCC,EAAAA,CAAC,EAAE;AARkC,CAAvC;;AAWA,MAAMC,aAAN,SAA4B5B,aAA5B,CAA2D;AAKzD6B,EAAAA,WAAW,CAACC,KAAD,EAAgB;AACzB,UAAMA,KAAN;;AADyB,oCAiFlB,MAAOC,MAAP,IAAmB;AAC1B,YAAM;AAAEC,QAAAA;AAAF,UAAY,KAAKC,KAAvB;;AACA,UAAI;AACF,cAAM,KAAKC,QAAL,CAAc;AAAEC,UAAAA,OAAO,EAAE;AAAX,SAAd,CAAN;AACA,cAAMC,IAAI,GAAG,MAAMrB,oBAAoB,CAACsB,MAArB,iCACdL,KADc,GAEbD,MAAM,IAAI,EAFG,EAAnB;AAIA,aAAKG,QAAL,CAAc;AACZI,UAAAA,UAAU,EAAEF,IAAI,CAACG,IAAL,CAAUA,IADV;AAEZC,UAAAA,KAAK,EAAEJ,IAAI,CAACG,IAAL,CAAUE;AAFL,SAAd;AAID,OAVD,CAUE,OAAOC,KAAP,EAAc;AACd,cAAMC,GAAG,GAAG,MAAMC,OAAO,CAACC,OAAR,CAAgBH,KAAhB,CAAlB;AACAnC,QAAAA,OAAO,CAACmC,KAAR,CAAclC,gBAAgB,CAACmC,GAAD,CAA9B;AACD,OAbD,SAaU;AACR,aAAKT,QAAL,CAAc;AAAEC,UAAAA,OAAO,EAAE;AAAX,SAAd;AACD;AACF,KAnG0B;;AAEzB,SAAKF,KAAL,GAAa;AACXD,MAAAA,KAAK,EAAEb,cADI;AAEXgB,MAAAA,OAAO,EAAE;AAFE,KAAb;AAID;;AAEsB,QAAjBW,iBAAiB,GAAG;AAAA;;AACxB,UAAM;AAAEC,MAAAA;AAAF,QAAa,KAAKjB,KAAxB;AACA,SAAKkB,MAAL,CAAY;AACVC,MAAAA,GAAG,EAAE,kBAAAF,MAAM,CAACf,KAAP,gEAAciB,GAAd,KAAqB,EADhB;AAEVtB,MAAAA,CAAC,EAAE,mBAAAoB,MAAM,CAACf,KAAP,kEAAcL,CAAd,KAAmB;AAFZ,KAAZ;AAIA,SAAKuB,0BAAL;AACD;;AAEDC,EAAAA,kBAAkB,CAACC,SAAD,EAAoBC,UAApB,EAAyC;AACzD,UAAM;AAAEN,MAAAA;AAAF,QAAa,KAAKjB,KAAxB;AACA,UAAM;AAAEE,MAAAA;AAAF,QAAY,KAAKC,KAAvB;;AACA,QACEc,MAAM,CAACf,KAAP,CAAaL,CAAb,KAAmByB,SAAS,CAACL,MAAV,CAAiBf,KAAjB,CAAuBL,CAA1C,IACGK,KAAK,KAAKqB,UAAU,CAACrB,KAF1B,EAGE;AAAA;;AACA,YAAML,CAAC,GAAG;AACRsB,QAAAA,GAAG,EAAE,mBAAAF,MAAM,CAACf,KAAP,kEAAciB,GAAd,KAAqB,EADlB;AAERtB,QAAAA,CAAC,EAAE,mBAAAoB,MAAM,CAACf,KAAP,kEAAcL,CAAd,KAAmB;AAFd,OAAV;AAIA,UAAIoB,MAAM,CAACf,KAAP,CAAaL,CAAb,KAAmByB,SAAS,CAACL,MAAV,CAAiBf,KAAjB,CAAuBL,CAA9C,EAAiDA,CAAC,CAACP,MAAF,GAAW,CAAX;AACjD,WAAK4B,MAAL,CAAYrB,CAAZ;AACD;;AAED,QAAIoB,MAAM,CAACf,KAAP,CAAaT,QAAb,KAA0B6B,SAAS,CAACL,MAAV,CAAiBf,KAAjB,CAAuBT,QAArD,EAA+D;AAC7D,WAAK+B,QAAL,CAAc,UAAd,EAA0BP,MAAM,CAACf,KAAP,CAAaT,QAAb,IAAyB,EAAnD;AACD;AACF;;AAEW,QAANgC,MAAM,CAACC,SAAD,EAAwB;AAClC,UAAM;AACJC,MAAAA,wBAAwB,EAAEC;AADtB,QAEF,KAAK5B,KAFT;AAGA,UAAM;AAAE6B,MAAAA,GAAF;AAAOC,MAAAA;AAAP,QAAsBJ,SAA5B;;AACA,QAAI;AACF,YAAMlD,gBAAgB,CAACuD,QAAjB,CAA0BF,GAA1B,EAA+BC,UAA/B,CAAN;AACAF,MAAAA,+BAA+B,CAACC,GAAD,CAA/B;AACD,KAHD,CAGE,OAAOjB,KAAP,EAAc;AACd,YAAMoB,CAAC,GAAG,MAAMlB,OAAO,CAACC,OAAR,CAAgBH,KAAhB,CAAhB;AACAnC,MAAAA,OAAO,CAACmC,KAAR,CAAclC,gBAAgB,CAACsD,CAAD,CAA9B;AACD;AACF;;AAEDC,EAAAA,SAAS,CAACC,IAAD,EAAeC,KAAf,EAA2B;AAClC,UAAM;AAAEjC,MAAAA;AAAF,QAAY,KAAKC,KAAvB;;AACA,QAAI+B,IAAI,KAAK,UAAT,IAAuBC,KAAK,KAAKjC,KAAK,CAACT,QAA3C,EAAqD;AACnDd,MAAAA,MAAM,CAACyD,IAAP,CAAY;AAAEC,QAAAA,QAAQ,EAAE,OAAZ;AAAqBnC,QAAAA,KAAK,EAAE;AAAET,UAAAA,QAAQ,EAAE0C;AAAZ;AAA5B,OAAZ,EAAgE,kBAAiBA,KAAM,EAAvF;AACA;AACD;;AAED,SAAK/B,QAAL,CAAc;AACZF,MAAAA,KAAK,kCACAA,KADA;AAEH,SAACgC,IAAD,GAAQC;AAFL;AADO,KAAd;AAMD;;AAEDX,EAAAA,QAAQ,CAACU,IAAD,EAAeC,KAAf,EAA2B;AACjC,UAAM;AAAEjC,MAAAA;AAAF,QAAY,KAAKC,KAAvB;AACA,SAAKC,QAAL,CAAc;AACZF,MAAAA,KAAK,kCACAA,KADA;AAEH,SAACgC,IAAD,GAAQC;AAFL;AADO,KAAd;AAMD;;AAE+B,QAA1Bf,0BAA0B,GAAG;AACjC,UAAMd,IAAI,GAAG,MAAMrB,oBAAoB,CAACqD,UAArB,CAAgC,EAAhC,CAAnB;AACA,UAAM,KAAKlC,QAAL,CAAc;AAAEkC,MAAAA,UAAU,EAAEhC,IAAI,CAACG;AAAnB,KAAd,CAAN;AACD;;AAsBD8B,EAAAA,WAAW,GAAG;AACZ,SAAKnC,QAAL,CAAc;AACZF,MAAAA,KAAK,EAAEb;AADK,KAAd;AAGD;;AAEDmD,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEC,MAAAA,EAAF;AAAMC,MAAAA;AAAN,QAAoB,KAAK1C,KAA/B;AACA,UAAM;AACJE,MAAAA,KADI;AACGM,MAAAA,UAAU,GAAG,EADhB;AACoB8B,MAAAA,UADpB;AACgC5B,MAAAA,KADhC;AACuCL,MAAAA;AADvC,QAEF,KAAKF,KAFT;AAGA,WACE,4BACE,MAAC,IAAD,QACE,qBACGsC,EADH,aACGA,EADH,uBACGA,EAAE,CAAEE,QADP,EAEG,GAFH,WADF,CADF,EAQE;AAAK,MAAA,SAAS,EAAC;AAAf,OACE,MAAC,gBAAD;AACE,MAAA,UAAU,EAAEL,UADd;AAEE,MAAA,SAAS,EAAEI,SAFb;AAGE,MAAA,SAAS,EAAE,KAAKT,SAAL,CAAeW,IAAf,CAAoB,IAApB,CAHb;AAIE,MAAA,WAAW,EAAE,KAAKL,WAAL,CAAiBK,IAAjB,CAAsB,IAAtB;AAJf,OAKM1C,KALN,EADF,EAQE,MAAC,MAAD;AAAQ,MAAA,QAAQ,EAAEG,OAAlB;AAA2B,MAAA,UAAU;AAArC,MARF,EASE,MAAC,aAAD,eACM,KAAKL,KADX;AAEE,MAAA,IAAI,EAAEQ,UAFR;AAGE,MAAA,KAAK,EAAEE,KAHT;AAIE,MAAA,OAAO,MAJT;AAKE,MAAA,MAAM,EAAE,KAAKe,MAAL,CAAYmB,IAAZ,CAAiB,IAAjB,CALV;AAME,MAAA,KAAK,EAAC,WANR;AAOE,MAAA,MAAM,MAPR;AAQE,MAAA,SAAS,EAAE,KAAKX,SAAL,CAAeW,IAAf,CAAoB,IAApB,CARb;AASE,MAAA,QAAQ,EAAEzD;AATZ,OAUMe,KAVN,EATF,CARF,CADF;AAkCD;;AAvJwD;;gBAArDJ,a,YACY,Q;;gBADZA,a,kBAGkB,K;;AAuJxB,MAAM+C,cAAc,GAAI1C,KAAD,IAAWA,KAAK,CAAC2C,MAAN,CAAaC,WAAb,CAAyBtC,IAA3D;;AACA,MAAMuC,YAAY,GAAGlE,cAAc,CAAC+D,cAAD,EAAkBI,OAAD,IAAa;AAC/D,MAAI,CAACA,OAAO,CAACC,MAAb,EAAqB,OAAO,EAAP;AAErB,SAAO;AACLC,IAAAA,UAAU,EAAEF,OAAO,CAACG,MAAR,CAAgBC,CAAD,IAAOA,CAAC,CAACC,QAAF,KAAe,KAArC,CADP;AAELC,IAAAA,YAAY,EAAEN,OAAO,CAACG,MAAR,CAAgBC,CAAD,IAAOA,CAAC,CAACC,QAAF,KAAe,OAArC,CAFT;AAGLE,IAAAA,aAAa,EAAEP,OAAO,CAACG,MAAR,CAAgBC,CAAD,IAAOA,CAAC,CAACC,QAAF,KAAe,QAArC;AAHV,GAAP;AAKD,CARkC,CAAnC;AAUAxD,aAAa,CAAC2D,WAAd,GAA4B1E,aAA5B;;AAEA,MAAM2E,eAAe,GAAIvD,KAAD;AACtBsC,EAAAA,EAAE,oBAAOtC,KAAK,CAACsC,EAAb;AADoB,GAEnBtC,KAAK,CAACuB,SAAN,CAAgBlB,UAFG;AAGtByC,EAAAA,OAAO,EAAED,YAAY,CAAC7C,KAAD,CAHC;AAItBuC,EAAAA,SAAS,EAAEvC,KAAK,CAACwD,QAAN,CAAejB,SAJJ;AAKtBkB,EAAAA,QAAQ,EAAEzD,KAAK,CAAC0D,IAAN,CAAWD,QALC,CAMtB;;AANsB,EAAxB;;AAQA,MAAME,WAAW,GAAG;AAClBjF,EAAAA,UADkB;AAElBP,EAAAA,iBAFkB;AAGlBC,EAAAA,mBAHkB;AAIlBF,EAAAA;AAJkB,CAApB;AAMA,eAAeD,OAAO,CAACsF,eAAD,EAAkBI,WAAlB,CAAP,CAAsClF,UAAU,CAACkB,aAAD,CAAhD,CAAf","sourcesContent":["import React, { PureComponent } from 'react';\nimport {\n  IPerformer,\n  ICountries,\n  IPerformSearch,\n  IUIConfig\n} from 'src/interfaces';\nimport PerformerGrid from '@components/performer/performer-grid';\nimport { connect } from 'react-redux';\nimport { loginSuccess } from '@redux/auth/actions';\nimport { updateCurrentUser } from '@redux/user/actions';\nimport { updateCurrentStudio } from '@redux/studio/actions';\nimport { favouriteService } from 'src/services';\nimport { message } from 'antd';\nimport { getResponseError } from '@lib/utils';\nimport Router, { withRouter, NextRouter } from 'next/router';\nimport { getBanners } from '@redux/banner/actions';\nimport { createSelector } from 'reselect';\nimport { SocketContext } from 'src/socket';\nimport Head from 'next/head';\nimport { camAggregatorService } from '@services/cam-aggregator.service';\nimport { IAggregatorCategogiesModel } from 'src/interfaces/aggregator-categories';\nimport AggregatorFilter from '@components/cam-aggregator/aggregator-filter';\nimport AggregatorProfileGridCard from '@components/cam-aggregator/grid-card';\nimport Loader from '@components/common/base/loader';\n\ninterface IProps {\n  router: NextRouter;\n  ui: IUIConfig;\n  data: IPerformer[];\n  searchPerformer?: Function;\n  total?: number;\n  success?: boolean;\n  error?: any;\n  searching?: boolean;\n  loggedIn?: boolean;\n  query?: {\n    q: string;\n  };\n  // categories?: IPerformerCategogies[];\n  countries?: ICountries[];\n  updatePerformerFavourite: Function;\n  getBanners: Function;\n  banners: any;\n  updateCurrentUser: Function;\n  updateCurrentPerformer: Function;\n  updateCurrentStudio: Function;\n  loginSuccess: Function;\n}\n\ninterface IStates {\n  query: IPerformSearch;\n  loading?: boolean;\n  sort?: {\n    name: string;\n    sortBy?: string;\n  };\n  performers?: any[];\n  categories?: IAggregatorCategogiesModel[];\n  total?: number;\n}\n\nconst initQueryState: IPerformSearch = {\n  offset: 0,\n  limit: 60,\n  gender: '',\n  category: '',\n  country: '',\n  sortBy: '',\n  sort: 'desc',\n  q: ''\n};\n\nclass CamAggregator extends PureComponent<IProps, IStates> {\n  static layout = 'public';\n\n  static authenticate = false;\n\n  constructor(props: IProps) {\n    super(props);\n    this.state = {\n      query: initQueryState,\n      loading: true\n    };\n  }\n\n  async componentDidMount() {\n    const { router } = this.props;\n    this.search({\n      tag: router.query?.tag || '',\n      q: router.query?.q || ''\n    });\n    this.getCamAggregatorCategories();\n  }\n\n  componentDidUpdate(prevProps: IProps, prevStates: IStates) {\n    const { router } = this.props;\n    const { query } = this.state;\n    if (\n      router.query.q !== prevProps.router.query.q\n      || query !== prevStates.query\n    ) {\n      const q = {\n        tag: router.query?.tag || '',\n        q: router.query?.q || ''\n      } as any;\n      if (router.query.q !== prevProps.router.query.q) q.offset = 0;\n      this.search(q);\n    }\n\n    if (router.query.category !== prevProps.router.query.category) {\n      this.setQuery('category', router.query.category || '');\n    }\n  }\n\n  async onLike(performer: IPerformer) {\n    const {\n      updatePerformerFavourite: dispatchUpdatePerformerFavorite\n    } = this.props;\n    const { _id, isFavorite } = performer;\n    try {\n      await favouriteService.favorite(_id, isFavorite);\n      dispatchUpdatePerformerFavorite(_id);\n    } catch (error) {\n      const e = await Promise.resolve(error);\n      message.error(getResponseError(e));\n    }\n  }\n\n  setFilter(name: string, value: any) {\n    const { query } = this.state;\n    if (name === 'category' && value !== query.category) {\n      Router.push({ pathname: '/cams', query: { category: value } }, `/cams?category=${value}`);\n      return;\n    }\n\n    this.setState({\n      query: {\n        ...query,\n        [name]: value\n      }\n    });\n  }\n\n  setQuery(name: string, value: any) {\n    const { query } = this.state;\n    this.setState({\n      query: {\n        ...query,\n        [name]: value\n      }\n    });\n  }\n\n  async getCamAggregatorCategories() {\n    const resp = await camAggregatorService.categories({});\n    await this.setState({ categories: resp.data });\n  }\n\n  search = async (params?) => {\n    const { query } = this.state;\n    try {\n      await this.setState({ loading: true });\n      const resp = await camAggregatorService.online({\n        ...query,\n        ...(params || {})\n      });\n      this.setState({\n        performers: resp.data.data,\n        total: resp.data.count\n      });\n    } catch (error) {\n      const err = await Promise.resolve(error);\n      message.error(getResponseError(err));\n    } finally {\n      this.setState({ loading: false });\n    }\n  };\n\n  clearFilter() {\n    this.setState({\n      query: initQueryState\n    });\n  }\n\n  render() {\n    const { ui, countries } = this.props;\n    const {\n      query, performers = [], categories, total, loading\n    } = this.state;\n    return (\n      <>\n        <Head>\n          <title>\n            {ui?.siteName}\n            {' '}\n            | Cams\n          </title>\n        </Head>\n        <div className=\"homepage\">\n          <AggregatorFilter\n            categories={categories}\n            countries={countries}\n            setFilter={this.setFilter.bind(this)}\n            clearFilter={this.clearFilter.bind(this)}\n            {...query}\n          />\n          <Loader spinning={loading} fullScreen />\n          <PerformerGrid\n            {...this.props}\n            data={performers}\n            total={total}\n            success\n            onLike={this.onLike.bind(this)}\n            title=\"Live cams\"\n            isPage\n            setFilter={this.setFilter.bind(this)}\n            gridCard={AggregatorProfileGridCard}\n            {...query}\n          />\n\n        </div>\n      </>\n    );\n  }\n}\n\nconst bannerSelecter = (state) => state.banner.listBanners.data;\nconst filterBanner = createSelector(bannerSelecter, (banners) => {\n  if (!banners.length) return {};\n\n  return {\n    topBanners: banners.filter((b) => b.position === 'top'),\n    rightBanners: banners.filter((b) => b.position === 'right'),\n    bottomBanners: banners.filter((b) => b.position === 'bottom')\n  };\n});\n\nCamAggregator.contextType = SocketContext;\n\nconst mapStateToProps = (state) => ({\n  ui: { ...state.ui },\n  ...state.performer.performers,\n  banners: filterBanner(state),\n  countries: state.settings.countries,\n  loggedIn: state.auth.loggedIn\n  // categories: state.performer.categories.data\n});\nconst mapDispatch = {\n  getBanners,\n  updateCurrentUser,\n  updateCurrentStudio,\n  loginSuccess\n};\nexport default connect(mapStateToProps, mapDispatch)(withRouter(CamAggregator));\n"]},"metadata":{},"sourceType":"module"}