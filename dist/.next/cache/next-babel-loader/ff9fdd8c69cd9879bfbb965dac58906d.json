{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router'; // import { connect } from 'react-redux';\n\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as _message } from 'antd';\nimport { generateUuid } from 'src/lib';\nimport env from '../env';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nimport { warning } from './utils';\nexport default function withAntmedia(Component) {\n  class AntMediaComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const pageProps = Component.getInitialProps && (await Component.getInitialProps(ctx)); // Return props.\n\n      return _objectSpread({}, pageProps);\n    }\n\n    constructor(props) {\n      super(props);\n\n      _defineProperty(this, \"webRTCAdaptor\", void 0);\n\n      _defineProperty(this, \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(this, \"onbeforeunload\", () => {\n        this.leaveSession();\n      });\n\n      const {\n        sessionId\n      } = this.props;\n      this.state = {\n        initialized: false,\n        publish_started: false,\n        streamId: sessionId\n      };\n    }\n\n    componentDidMount() {\n      const {\n        initImmediately\n      } = this.props;\n      initImmediately && this.initWebRTCAdaptor();\n      Router.events.on('routeChangeStart', this.onbeforeunload);\n      window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('beforeunload', this.onbeforeunload);\n      Router.events.off('routeChangeStart', this.onbeforeunload);\n    }\n\n    leaveSession() {\n      const {\n        streamId,\n        publish_started,\n        initialized\n      } = this.state;\n      const {\n        configs: {\n          isPlayMode\n        }\n      } = this.props;\n\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n      }\n\n      if (this.webRTCAdaptor && initialized) {\n        publish_started && streamId && this.webRTCAdaptor.stop(streamId);\n        !isPlayMode && this.webRTCAdaptor.closeStream();\n        this.webRTCAdaptor.closePeerConnection();\n        this.webRTCAdaptor.closeWebSocket();\n        this.webRTCAdaptor = undefined;\n      }\n\n      this.setState({\n        streamId: '',\n        initialized: false // publish_started: false\n\n      });\n    }\n\n    initWebRTCAdaptor(cb, cbError) {\n      const {\n        configs,\n        settings,\n        autoRepublishDisabled,\n        callback\n      } = this.props;\n      const {\n        isPlayMode\n      } = configs;\n      const {\n        debug\n      } = env;\n      const publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n      if (!publisherURL) {\n        _message.error('Undefined WebsocketURL!');\n\n        return;\n      }\n\n      if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n      const pc_config = {\n        iceServers: [{\n          urls: 'stun:stun.l.google.com:19302'\n        }]\n      };\n      const sdpConstraints = {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      };\n      const mediaConstraints = {\n        video: true,\n        audio: true\n      };\n      const appName = configs.appName || settings.AntMediaAppname;\n      const path = `${publisherURL}/${appName}/websocket`;\n      let websocketURL = `ws://${path}`;\n\n      if (window.location.protocol.startsWith('https')) {\n        websocketURL = `wss://${path}`;\n      }\n\n      this.setState({\n        cb,\n        cbError\n      });\n      this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread(_objectSpread({\n        websocket_url: websocketURL,\n        mediaConstraints,\n        debug,\n        peerconnection_config: pc_config,\n        sdp_constraints: sdpConstraints,\n        bandwidth: env.maxVideoBitrateKbps,\n        isPlayMode: false\n      }, configs), {}, {\n        callback: (info, obj) => {\n          if (info === 'initialized') {\n            this.setState({\n              initialized: true\n            });\n          } else if (info === 'publish_started') {\n            this.setState({\n              publish_started: true,\n              streamId: obj.streamId\n            });\n\n            if (!this.autoRepublishIntervalJob && !autoRepublishDisabled) {\n              this.autoRepublishIntervalJob = setInterval(this.checkAndRepublishIfRequired.bind(this), 5000);\n            }\n          } else if (info === 'publish_finished') {\n            this.setState({\n              publish_started: false,\n              streamId: ''\n            }); // if (this.autoRepublishIntervalJob) {\n            //   window.clearInterval(this.autoRepublishIntervalJob);\n            // }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n            this.setState({\n              iceConnectionState: obj.state\n            });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n            const {\n              publish_started\n            } = this.state;\n\n            if (publish_started && !autoRepublishDisabled) {\n              this.checkAndRepublishIfRequired();\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n            // this.leaveSession();\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log(`Connecton closed: ${JSON.stringify(obj)}`);\n            }\n          }\n\n          callback && typeof callback === 'function' && callback(info, obj); // props\n\n          cb && typeof cb === 'function' && cb(info, obj); // param\n        },\n        callbackError: (error, message) => {\n          cbError && typeof cbError === 'function' && cbError(error, message);\n          this.callbackError(error, message);\n        }\n      }));\n    }\n\n    checkAndRepublishIfRequired() {\n      const {\n        streamId,\n        cb,\n        cbError\n      } = this.state;\n      if (!this.webRTCAdaptor || !streamId) return;\n      const iceState = this.webRTCAdaptor.iceConnectionState(streamId);\n\n      if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n        warning('Publish has stopped and will try to re-publish');\n        this.webRTCAdaptor.stop(streamId);\n        this.webRTCAdaptor.closePeerConnection(streamId);\n        this.webRTCAdaptor.closeWebSocket();\n        this.initWebRTCAdaptor(cb, cbError);\n      }\n    }\n\n    callbackError(error, message) {\n      // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n      warning(`error callback: ${JSON.stringify(error)}`);\n      let errorMessage = JSON.stringify(error);\n\n      if (typeof message !== 'undefined') {\n        errorMessage = message;\n\n        _message.error(errorMessage);\n\n        warning(errorMessage);\n        return;\n      }\n\n      warning(errorMessage);\n\n      if (errorMessage.indexOf('NotFoundError') !== -1) {\n        errorMessage = 'Camera or Mic are not found or not allowed in your device';\n      } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n        errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n      } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n        errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n      } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n        errorMessage = 'You are not allowed to access camera and mic.';\n      } else if (errorMessage.indexOf('TypeError') !== -1) {\n        errorMessage = 'Video/Audio is required';\n      } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n        errorMessage = 'You are not allowed to access screen share';\n      } else if (errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n        errorMessage = 'WebSocket Connection is disconnected.';\n      } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n        errorMessage = 'Access Denied. You donâ€™t have permission to access'; // this.leaveSession();\n      } else {\n        errorMessage = '';\n      }\n\n      const key = generateUuid();\n      errorMessage && _message.error({\n        content: errorMessage,\n        key,\n        onClick: () => _message.destroy(key)\n      });\n    }\n\n    render() {\n      const {\n        forwardedRef\n      } = this.props;\n      return __jsx(Component, _extends({}, this.props, this.state, {\n        webRTCAdaptor: this.webRTCAdaptor,\n        initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n        leaveSession: this.leaveSession.bind(this),\n        ref: forwardedRef\n      }));\n    }\n\n  }\n\n  return /*#__PURE__*/React.forwardRef((props, ref) => __jsx(AntMediaComponent, _extends({}, props, {\n    forwardedRef: ref\n  }))); // const mapStateToProps = (state) => ({ settings: state.streaming.settings });\n  // const MapComponent = connect(mapStateToProps)(AntMediaComponent);\n}","map":null,"metadata":{},"sourceType":"module"}