{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router'; // import { connect } from 'react-redux';\n\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as _message } from 'antd';\nimport { generateUuid } from 'src/lib';\nimport env from '../env';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nimport { warning } from './utils';\nexport default function withAntmedia(Component) {\n  var AntMediaComponent = /*#__PURE__*/function (_React$Component) {\n    _inherits(AntMediaComponent, _React$Component);\n\n    var _super = _createSuper(AntMediaComponent);\n\n    function AntMediaComponent(props) {\n      var _this;\n\n      _classCallCheck(this, AntMediaComponent);\n\n      _this = _super.call(this, props);\n\n      _defineProperty(_assertThisInitialized(_this), \"webRTCAdaptor\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(_assertThisInitialized(_this), \"onbeforeunload\", function () {\n        _this.leaveSession();\n      });\n\n      _this.state = {\n        initialized: false,\n        publish_started: false\n      };\n      return _this;\n    }\n\n    _createClass(AntMediaComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var initImmediately = this.props.initImmediately;\n        initImmediately && this.initWebRTCAdaptor();\n        Router.events.on('routeChangeStart', this.onbeforeunload);\n        window.addEventListener('beforeunload', this.onbeforeunload);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        window.removeEventListener('beforeunload', this.onbeforeunload);\n        Router.events.off('routeChangeStart', this.onbeforeunload);\n      }\n    }, {\n      key: \"leaveSession\",\n      value: function leaveSession() {\n        var _this$state = this.state,\n            streamId = _this$state.streamId,\n            publish_started = _this$state.publish_started,\n            initialized = _this$state.initialized;\n        var isPlayMode = this.props.configs.isPlayMode;\n\n        if (this.autoRepublishIntervalJob) {\n          window.clearInterval(this.autoRepublishIntervalJob);\n        }\n\n        if (this.webRTCAdaptor && initialized) {\n          publish_started && streamId && this.webRTCAdaptor.stop(streamId);\n          !isPlayMode && this.webRTCAdaptor.closeStream();\n          this.webRTCAdaptor.closePeerConnection();\n          this.webRTCAdaptor.closeWebSocket();\n          this.webRTCAdaptor = undefined;\n        }\n\n        this.setState({\n          streamId: '',\n          initialized: false // publish_started: false\n\n        });\n      }\n    }, {\n      key: \"initWebRTCAdaptor\",\n      value: function initWebRTCAdaptor(cb, cbError) {\n        var _this2 = this;\n\n        var _this$props = this.props,\n            configs = _this$props.configs,\n            settings = _this$props.settings,\n            autoRepublishDisabled = _this$props.autoRepublishDisabled,\n            _callback = _this$props.callback;\n        var isPlayMode = configs.isPlayMode;\n        var debug = env.debug;\n        var publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n        if (!publisherURL) {\n          _message.error('Undefined WebsocketURL!');\n\n          return;\n        }\n\n        if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n        var pc_config = {\n          iceServers: [{\n            urls: 'stun:stun.l.google.com:19302'\n          }]\n        };\n        var sdpConstraints = {\n          OfferToReceiveAudio: false,\n          OfferToReceiveVideo: false\n        };\n        var mediaConstraints = {\n          video: true,\n          audio: true\n        };\n        var appName = configs.appName || settings.AntMediaAppname;\n        var path = \"\".concat(publisherURL, \"/\").concat(appName, \"/websocket\");\n        var websocketURL = \"ws://\".concat(path);\n\n        if (window.location.protocol.startsWith('https')) {\n          websocketURL = \"wss://\".concat(path);\n        }\n\n        this.setState({\n          cb: cb,\n          cbError: cbError\n        });\n        this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread(_objectSpread({\n          websocket_url: websocketURL,\n          mediaConstraints: mediaConstraints,\n          debug: debug,\n          peerconnection_config: pc_config,\n          sdp_constraints: sdpConstraints,\n          bandwidth: env.maxVideoBitrateKbps,\n          isPlayMode: false\n        }, configs), {}, {\n          callback: function callback(info, obj) {\n            if (info === 'initialized') {\n              _this2.setState({\n                initialized: true\n              });\n            } else if (info === 'publish_started') {\n              _this2.setState({\n                publish_started: true,\n                streamId: obj.streamId\n              });\n\n              if (!_this2.autoRepublishIntervalJob && !autoRepublishDisabled) {\n                _this2.autoRepublishIntervalJob = setInterval(_this2.checkAndRepublishIfRequired.bind(_this2), 5000);\n              }\n            } else if (info === 'publish_finished') {\n              _this2.setState({\n                publish_started: false,\n                streamId: ''\n              }); // if (this.autoRepublishIntervalJob) {\n              //   window.clearInterval(this.autoRepublishIntervalJob);\n              // }\n\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n              _this2.setState({\n                iceConnectionState: obj.state\n              });\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n              var publish_started = _this2.state.publish_started;\n\n              if (publish_started && !autoRepublishDisabled) {\n                _this2.checkAndRepublishIfRequired();\n              }\n            } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n              // this.leaveSession();\n              if (typeof obj !== 'undefined') {\n                // eslint-disable-next-line no-console\n                console.log(\"Connecton closed: \".concat(JSON.stringify(obj)));\n              }\n            }\n\n            _callback && typeof _callback === 'function' && _callback(info, obj); // props\n\n            cb && typeof cb === 'function' && cb(info, obj); // param\n          },\n          callbackError: function callbackError(error, message) {\n            cbError && typeof cbError === 'function' && cbError(error, message);\n\n            _this2.callbackError(error, message);\n          }\n        }));\n      }\n    }, {\n      key: \"checkAndRepublishIfRequired\",\n      value: function checkAndRepublishIfRequired() {\n        var _this$state2 = this.state,\n            streamId = _this$state2.streamId,\n            cb = _this$state2.cb,\n            cbError = _this$state2.cbError;\n        if (!this.webRTCAdaptor || !streamId) return;\n        var iceState = this.webRTCAdaptor.iceConnectionState(streamId);\n\n        if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n          warning('Publish has stopped and will try to re-publish');\n          this.webRTCAdaptor.stop(streamId);\n          this.webRTCAdaptor.closePeerConnection(streamId);\n          this.webRTCAdaptor.closeWebSocket();\n          this.initWebRTCAdaptor(cb, cbError);\n        }\n      }\n    }, {\n      key: \"callbackError\",\n      value: function callbackError(error, message) {\n        // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n        warning(\"error callback: \".concat(JSON.stringify(error)));\n        var errorMessage = JSON.stringify(error);\n\n        if (typeof message !== 'undefined') {\n          errorMessage = message;\n\n          _message.error(errorMessage);\n\n          warning(errorMessage);\n          return;\n        }\n\n        warning(errorMessage);\n\n        if (errorMessage.indexOf('NotFoundError') !== -1) {\n          errorMessage = 'Camera or Mic are not found or not allowed in your device';\n        } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n          errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n        } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n          errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n        } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n          errorMessage = 'You are not allowed to access camera and mic.';\n        } else if (errorMessage.indexOf('TypeError') !== -1) {\n          errorMessage = 'Video/Audio is required';\n        } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n          errorMessage = 'You are not allowed to access screen share';\n        } else if (errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n          errorMessage = 'WebSocket Connection is disconnected.';\n        } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n          errorMessage = 'Access Denied. You don’t have permission to access'; // this.leaveSession();\n        } else {\n          errorMessage = '';\n        }\n\n        var key = generateUuid();\n        errorMessage && _message.error({\n          content: errorMessage,\n          key: key,\n          onClick: function onClick() {\n            return _message.destroy(key);\n          }\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var forwardedRef = this.props.forwardedRef;\n        return __jsx(Component, _extends({}, this.props, this.state, {\n          webRTCAdaptor: this.webRTCAdaptor,\n          initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n          leaveSession: this.leaveSession.bind(this),\n          ref: forwardedRef\n        }));\n      }\n    }], [{\n      key: \"getInitialProps\",\n      value: function () {\n        var _getInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n          var pageProps;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.t0 = Component.getInitialProps;\n\n                  if (!_context.t0) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  _context.next = 4;\n                  return Component.getInitialProps(ctx);\n\n                case 4:\n                  _context.t0 = _context.sent;\n\n                case 5:\n                  pageProps = _context.t0;\n                  return _context.abrupt(\"return\", _objectSpread({}, pageProps));\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function getInitialProps(_x) {\n          return _getInitialProps.apply(this, arguments);\n        }\n\n        return getInitialProps;\n      }()\n    }]);\n\n    return AntMediaComponent;\n  }(React.Component);\n\n  return /*#__PURE__*/React.forwardRef(function (props, ref) {\n    return __jsx(AntMediaComponent, _extends({}, props, {\n      forwardedRef: ref\n    }));\n  }); // const mapStateToProps = (state) => ({ settings: state.streaming.settings });\n  // const MapComponent = connect(mapStateToProps)(AntMediaComponent);\n}","map":null,"metadata":{},"sourceType":"module"}