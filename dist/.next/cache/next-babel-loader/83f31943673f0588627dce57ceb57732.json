{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport * as React from 'react';\nimport { streamService } from 'src/services';\nimport classnames from 'classnames';\nimport withAntMedia from 'src/antmedia';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport './index.less';\n\nclass Subscriber extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"streamId\", void 0);\n\n    _defineProperty(this, \"activeStreams\", []);\n  }\n\n  async handler(info, obj) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      const token = await streamService.getSubscriberToken({\n        streamId: this.streamId,\n        settings\n      });\n      webRTCAdaptor.play(this.streamId, token);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.NEW_STREAM_AVAILABLE) {\n      const activeStream = this.activeStreams.find(id => id === obj.streamId);\n\n      if (!activeStream) {\n        this.activeStreams.push(obj.streamId);\n        this.createRemoteVideo(obj.stream);\n      }\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.PLAY_FINISHED) {\n      this.activeStreams = this.activeStreams.filter(id => id !== obj.streamId);\n      this.removeRemoteVideo();\n      setTimeout(() => {\n        webRTCAdaptor.getStreamInfo(obj.streamId);\n      }, 3000);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.STREAM_INFORMATION) {\n      if (obj.streamId === this.streamId) {\n        const token = await streamService.getSubscriberToken({\n          streamId: obj.streamId,\n          settings\n        });\n        webRTCAdaptor.play(obj.streamId, token);\n      }\n    }\n  }\n\n  async cbErrorHandler(error) {\n    if (error === 'no_stream_exist') {\n      const {\n        webRTCAdaptor,\n        initWebRTCAdaptor\n      } = this.props;\n\n      if (!webRTCAdaptor) {\n        initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n      } else {\n        this.streamId && webRTCAdaptor.getStreamInfo(this.streamId);\n      }\n    }\n  }\n\n  createRemoteVideo(stream) {\n    const {\n      classNames\n    } = this.props;\n    const video = document.createElement('video');\n    video.setAttribute('id', 'private-subscriber');\n    video.setAttribute('class', classnames('video-js', classNames));\n    video.autoplay = true;\n    video.muted = true;\n    video.controls = true;\n    video.playsInline = true;\n    video.srcObject = stream;\n    document.querySelector('.private-streaming-container').append(video);\n  }\n\n  removeRemoteVideo() {\n    const video = document.getElementById('private-subscriber');\n\n    if (video) {\n      video.srcObject = null;\n      document.querySelector('.private-streaming-container').removeChild(video);\n    }\n  }\n\n  async play(streamId) {\n    const {\n      initWebRTCAdaptor,\n      initialized,\n      webRTCAdaptor,\n      settings\n    } = this.props;\n\n    if (initialized) {\n      const token = await streamService.getSubscriberToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.play(streamId, token);\n      return;\n    }\n\n    this.streamId = streamId;\n    initWebRTCAdaptor(this.handler.bind(this), this.cbErrorHandler.bind(this));\n  }\n\n  close() {\n    this.streamId = null;\n  }\n\n  stop() {\n    const {\n      leaveSession\n    } = this.props;\n    leaveSession();\n  }\n\n  render() {\n    return __jsx(React.Fragment, null);\n  }\n\n}\n\nexport default withAntMedia(Subscriber);","map":null,"metadata":{},"sourceType":"module"}