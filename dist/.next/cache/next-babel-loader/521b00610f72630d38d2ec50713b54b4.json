{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport React from 'react';\nimport Router from 'next/router'; // import { connect } from 'react-redux';\n\nimport { SETTING_KEYS } from 'src/constants';\nimport { message as _message } from 'antd';\nimport env from '../env';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from './constants';\nexport default function withAntmedia(Component) {\n  class AntMediaComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const pageProps = Component.getInitialProps && (await Component.getInitialProps(ctx)); // Return props.\n\n      return _objectSpread({}, pageProps);\n    }\n\n    constructor(props) {\n      super(props);\n\n      _defineProperty(this, \"webRTCAdaptor\", void 0);\n\n      _defineProperty(this, \"autoRepublishIntervalJob\", void 0);\n\n      _defineProperty(this, \"onbeforeunload\", () => {\n        this.leaveSession();\n      });\n\n      const {\n        sessionId\n      } = this.props;\n      this.state = {\n        initialized: false,\n        publish_started: false,\n        isMicMuted: false,\n        streamId: sessionId\n      };\n    }\n\n    componentDidMount() {\n      const {\n        initImmediately\n      } = this.props;\n      initImmediately && this.initWebRTCAdaptor();\n      Router.events.on('routeChangeStart', this.onbeforeunload); // window.addEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    componentWillUnmount() {\n      Router.events.off('routeChangeStart', this.onbeforeunload); // window.removeEventListener('beforeunload', this.onbeforeunload);\n    }\n\n    leaveSession() {\n      const {\n        streamId,\n        initialized\n      } = this.state;\n      const {\n        configs: {\n          isPlayMode\n        }\n      } = this.props;\n\n      if (this.autoRepublishIntervalJob) {\n        window.clearInterval(this.autoRepublishIntervalJob);\n      }\n\n      if (this.webRTCAdaptor) {\n        if (streamId) {\n          this.webRTCAdaptor.stop(streamId);\n          this.webRTCAdaptor.closePeerConnection(streamId);\n\n          if (!isPlayMode) {\n            this.webRTCAdaptor.closeStream(streamId);\n          }\n        }\n\n        if (initialized) {\n          this.webRTCAdaptor.closeWebSocket();\n        }\n\n        this.webRTCAdaptor = undefined;\n      }\n\n      this.setState({\n        streamId: '',\n        initialized: false,\n        isMicMuted: false\n      });\n    }\n\n    initWebRTCAdaptor(cb, cbError) {\n      const {\n        configs,\n        settings,\n        autoRepublishDisabled,\n        callback\n      } = this.props;\n      const {\n        isPlayMode\n      } = configs;\n      const {\n        debug\n      } = env;\n      const publisherURL = isPlayMode ? settings[SETTING_KEYS.SUBSCRIBER_URL] : settings[SETTING_KEYS.PUBLISHER_URL];\n\n      if (!publisherURL) {\n        _message.error('Undefined WebsocketURL!');\n\n        return;\n      }\n\n      if (!this.webRTCAdaptor && autoRepublishDisabled) return;\n      const pc_config = {\n        iceServers: [{\n          urls: 'stun:stun.l.google.com:19302'\n        }]\n      };\n      const sdpConstraints = {\n        OfferToReceiveAudio: false,\n        OfferToReceiveVideo: false\n      };\n      const mediaConstraints = {\n        video: true,\n        audio: true\n      };\n      const appName = configs.appName || settings.AntMediaAppname;\n      const path = `${publisherURL}/${appName}/websocket`;\n      let websocketURL = `ws://${path}`;\n\n      if (window.location.protocol.startsWith('https')) {\n        websocketURL = `wss://${path}`;\n      }\n\n      this.setState({\n        cb,\n        cbError\n      });\n      this.webRTCAdaptor = new window['WebRTCAdaptor'](_objectSpread(_objectSpread({\n        websocket_url: websocketURL,\n        mediaConstraints,\n        debug,\n        peerconnection_config: pc_config,\n        sdp_constraints: sdpConstraints,\n        bandwidth: env.maxVideoBitrateKbps,\n        isPlayMode: false\n      }, configs), {}, {\n        callback: (info, obj) => {\n          if (info === 'initialized') {\n            this.setState({\n              initialized: true\n            });\n          } else if (info === 'publish_started') {\n            this.setState({\n              publish_started: true,\n              streamId: obj.streamId\n            });\n\n            if (!this.autoRepublishIntervalJob && !autoRepublishDisabled) {\n              this.autoRepublishIntervalJob = setInterval(this.checkAndRepublishIfRequired.bind(this), 5000);\n            }\n          } else if (info === 'publish_finished') {\n            this.setState({\n              publish_started: false,\n              streamId: ''\n            }); // if (this.autoRepublishIntervalJob) {\n            //   window.clearInterval(this.autoRepublishIntervalJob);\n            // }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.ICE_CONNECTION_STATE_CHANGED) {\n            this.setState({\n              iceConnectionState: obj.state\n            });\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.REFRESH_CONNECTION) {\n            const {\n              publish_started\n            } = this.state;\n\n            if (publish_started && !autoRepublishDisabled) {\n              this.checkAndRepublishIfRequired();\n            }\n          } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.CLOSED) {\n            // this.leaveSession();\n            if (typeof obj !== 'undefined') {\n              // eslint-disable-next-line no-console\n              console.log(`Connecton closed: ${JSON.stringify(obj)}`);\n            }\n          }\n\n          callback && typeof callback === 'function' && callback(info, obj); // props\n\n          cb && typeof cb === 'function' && cb(info, obj); // param\n        },\n        callbackError: (error, message) => {\n          cbError && typeof cbError === 'function' && cbError(error, message);\n          this.callbackError(error, message, {\n            websocketURL\n          });\n        }\n      }));\n    }\n\n    checkAndRepublishIfRequired() {\n      try {\n        const {\n          streamId,\n          cb,\n          cbError\n        } = this.state;\n        if (!this.webRTCAdaptor || !streamId) return;\n        const iceState = this.webRTCAdaptor.iceConnectionState(streamId);\n\n        if (iceState == null || iceState === 'failed' || iceState === 'disconnected') {\n          // eslint-disable-next-line no-console\n          console.error('Publish has stopped and will try to re-publish');\n          this.webRTCAdaptor.stop(streamId);\n          this.webRTCAdaptor.closePeerConnection(streamId);\n          this.webRTCAdaptor.closeWebSocket();\n          this.initWebRTCAdaptor(cb, cbError);\n        }\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('error republish', e);\n      }\n    }\n\n    callbackError(error, message, options) {\n      // some of the possible errors, NotFoundError, SecurityError,PermissionDeniedError\n      // eslint-disable-next-line no-console\n      console.error(`error callback: ${JSON.stringify(error)}`);\n      const {\n        websocketURL\n      } = options;\n\n      if (typeof message === 'string') {\n        // eslint-disable-next-line no-console\n        console.error('error message:', message);\n\n        _message.error(message, 3);\n\n        return;\n      }\n\n      let errorMessage = JSON.stringify(error);\n\n      if (errorMessage.indexOf('noStreamNameSpecified') !== -1) {\n        // eslint-disable-next-line no-console\n        console.warn(errorMessage);\n        return;\n      }\n\n      if (errorMessage.indexOf('NotFoundError') !== -1) {\n        errorMessage = 'Camera or Mic are not found or not allowed in your device';\n      } else if (errorMessage.indexOf('NotReadableError') !== -1 || errorMessage.indexOf('TrackStartError') !== -1) {\n        errorMessage = 'Camera or Mic is being used by some other process that does not let read the devices';\n      } else if (errorMessage.indexOf('OverconstrainedError') !== -1 || errorMessage.indexOf('ConstraintNotSatisfiedError') !== -1) {\n        errorMessage = 'There is no device found that fits your video and audio constraints. You may change video and audio constraints';\n      } else if (errorMessage.indexOf('NotAllowedError') !== -1 || errorMessage.indexOf('PermissionDeniedError') !== -1) {\n        errorMessage = 'You are not allowed to access camera and mic.';\n      } else if (errorMessage.indexOf('TypeError') !== -1) {\n        errorMessage = 'Video/Audio is required';\n      } else if (errorMessage.indexOf('ScreenSharePermissionDenied') !== -1) {\n        errorMessage = 'You are not allowed to access screen share';\n      } else if (errorMessage.indexOf('WebSocketNotConnected') !== -1) {\n        errorMessage = 'WebRTCAdaptor Connection is disconnected';\n      } else if (errorMessage.indexOf('unauthorized_access') !== -1) {\n        errorMessage = 'Access Denied. You don’t have permission to access';\n      } else if (errorMessage.indexOf('streamIdInUse') !== -1) {\n        errorMessage = 'Stream have been already published. Please close the previous connection.';\n      } else if (errorMessage.indexOf('publishTimeoutError') !== -1) {\n        errorMessage = 'WebRTC Publishing Timeout Error';\n      } else if (errorMessage.indexOf('not_allowed_unregistered_streams') !== -1) {\n        errorMessage = 'Stream with an unregistered id is not allowed';\n      } else if (errorMessage.indexOf('UnsecureContext') !== -1) {\n        errorMessage = 'Fatal Error: Browser cannot access camera and mic because of unsecure context. Please install SSL and access via https';\n      } else if (errorMessage.indexOf('WebSocketNotSupported') !== -1) {\n        errorMessage = 'Fatal Error: WebSocket not supported in this browser';\n      } else if (errorMessage.indexOf('AudioAlreadyActive') !== -1) {\n        errorMessage = 'AudioAlreadyActive';\n      } else if (errorMessage.indexOf('isTrusted') !== -1) {\n        errorMessage = `WebSocket connection to ${websocketURL} failed`;\n        window.location.reload();\n      } else {\n        errorMessage = 'WebRTCAdaptor Connection Error';\n      }\n\n      errorMessage && _message.error(errorMessage, 3);\n    }\n\n    muteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.muteLocalMic();\n        this.setState({\n          isMicMuted: true\n        });\n\n        _message.success('Muted local mic successfully');\n      }\n    }\n\n    unmuteLocalMic() {\n      if (this.webRTCAdaptor) {\n        this.webRTCAdaptor.unmuteLocalMic();\n        this.setState({\n          isMicMuted: false\n        });\n\n        _message.success('Unmuted local mic successfully');\n      }\n    }\n\n    render() {\n      const {\n        forwardedRef\n      } = this.props;\n      return __jsx(Component, _extends({}, this.props, this.state, {\n        webRTCAdaptor: this.webRTCAdaptor,\n        initWebRTCAdaptor: this.initWebRTCAdaptor.bind(this),\n        muteLocalMic: this.muteLocalMic.bind(this),\n        unmuteLocalMic: this.unmuteLocalMic.bind(this),\n        leaveSession: this.leaveSession.bind(this),\n        ref: forwardedRef\n      }));\n    }\n\n  }\n\n  return /*#__PURE__*/React.forwardRef((props, ref) => __jsx(AntMediaComponent, _extends({}, props, {\n    forwardedRef: ref\n  }))); // const mapStateToProps = (state) => ({ settings: state.streaming.settings });\n  // const MapComponent = connect(mapStateToProps)(AntMediaComponent);\n}","map":null,"metadata":{},"sourceType":"module"}