{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport { streamService } from 'src/services';\nimport Router from 'next/router';\nimport classnames from 'classnames';\nimport React, { PureComponent } from 'react';\nimport withAntmedia from 'src/antmedia';\nimport { WEBRTC_ADAPTOR_INFORMATIONS } from 'src/antmedia/constants';\nimport { SocketContext } from 'src/socket';\n\nclass Publisher extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"onbeforeunload\", () => {\n      const {\n        publish_started,\n        webRTCAdaptor\n      } = this.props;\n      const {\n        conversationId,\n        streamId\n      } = this.state;\n\n      if (publish_started) {\n        webRTCAdaptor && webRTCAdaptor.leaveFromRoom(conversationId);\n        this.socket.emit('private-stream/leave', {\n          conversationId,\n          streamId\n        });\n      }\n    });\n\n    this.state = {\n      conversationId: ''\n    };\n  }\n\n  componentDidMount() {\n    const {\n      id,\n      containerClassName\n    } = this.props;\n    this.socket = this.context;\n    Router.events.on('routeChangeStart', this.onbeforeunload);\n    window.addEventListener('beforeunload', this.onbeforeunload);\n    const video = document.getElementById(id);\n    const container = document.getElementsByClassName(containerClassName)[0];\n    video.width = container.clientWidth / 4;\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.onbeforeunload);\n    Router.events.off('routeChangeStart', this.onbeforeunload);\n  }\n\n  async handler(info) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    const {\n      conversationId,\n      streamId\n    } = this.state;\n\n    if (info === WEBRTC_ADAPTOR_INFORMATIONS.INITIALIZED) {\n      webRTCAdaptor.joinRoom(conversationId, streamId);\n    } else if (info === WEBRTC_ADAPTOR_INFORMATIONS.JOINED_THE_ROOM) {\n      const token = await streamService.getPublishToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.publish(streamId, token);\n    } else if (info === 'publish_started') {\n      this.socket.emit('private-stream/join', {\n        conversationId,\n        streamId\n      });\n    } else if (info === 'publish_finished') {\n      this.socket.emit('private-stream/leave', {\n        conversationId,\n        streamId\n      });\n    }\n  }\n\n  start(conversationId) {\n    this.setState({\n      conversationId\n    });\n  }\n\n  publish(streamId) {\n    const {\n      initWebRTCAdaptor\n    } = this.props;\n    this.setState({\n      streamId\n    });\n    initWebRTCAdaptor(this.handler.bind(this));\n  }\n\n  stop() {\n    const {\n      leaveSession\n    } = this.props;\n    leaveSession();\n  }\n\n  render() {\n    const {\n      publish_started,\n      id,\n      classNames\n    } = this.props;\n    return __jsx(\"video\", {\n      id: id,\n      className: classnames('video-js', classNames),\n      hidden: !publish_started,\n      autoPlay: true,\n      playsInline: true,\n      muted: true\n    });\n  }\n\n}\n\nPublisher.contextType = SocketContext;\nexport default withAntmedia(Publisher);","map":null,"metadata":{},"sourceType":"module"}