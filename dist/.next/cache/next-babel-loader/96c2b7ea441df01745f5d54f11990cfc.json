{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable dot-notation */\n\n/* eslint-disable camelcase */\nimport React, { PureComponent } from 'react';\nimport withAntmedia from 'src/antmedia';\nimport { Button, message } from 'antd';\nimport Router from 'next/router';\nimport { SocketContext } from 'src/socket';\nimport { streamService } from 'src/services';\nimport { getResponseError } from '@lib/utils';\nimport videojs from 'video.js';\nimport './group-streaming-container.less';\nconst STREAM_JOINED = 'private-stream/streamJoined';\nconst STREAM_LEAVED = 'private-stream/streamLeaved';\nconst JOINED_THE_ROOM = 'JOINED_THE_ROOM';\n\nclass GroupStreamingContainer extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"players\", void 0);\n\n    _defineProperty(this, \"getLiveStreamOrVodURLInterval\", void 0);\n\n    this.state = {\n      sessionId: '',\n      // roomName\n      streamId: '',\n      streamList: [],\n      conversationId: '',\n      loading: false\n    };\n  }\n\n  componentDidMount() {\n    const {\n      initWebRTCAdaptor\n    } = this.props;\n    this.socket = this.context;\n    this.socket.on(JOINED_THE_ROOM, data => {\n      const {\n        streamId,\n        streamList,\n        conversationId: _id\n      } = data;\n      const {\n        conversationId\n      } = this.state;\n      if (_id !== conversationId) return;\n      this.setState({\n        streamId,\n        streamList\n      });\n      initWebRTCAdaptor(this.onHandlePrivateStream.bind(this));\n\n      if (streamList.length) {\n        streamList.forEach(id => {\n          const player = document.createElement('video');\n          const container = document.getElementById('group-video-container');\n          player.setAttribute('id', id);\n          player.setAttribute('class', 'video-js');\n          player.setAttribute('autoplay', 'autoplay');\n          container.append(player);\n          this.players[`player${id}`] = videojs(id, {\n            // height: 145,\n            width: container.offsetWidth / 4,\n            liveui: true,\n            controls: false\n          }, () => this.onReadyCallback(id));\n        });\n      }\n    });\n    this.socket.on(STREAM_LEAVED, data => {\n      const {\n        streamList\n      } = this.state;\n      this.setState({\n        streamList: streamList.filter(id => id !== data.streamId)\n      });\n\n      if (this.players[`player${data.streamId}`]) {\n        this.players[`player${data.streamId}`].dispose();\n        delete this.players[`player${data.streamId}`];\n      }\n    });\n    this.socket.on(STREAM_JOINED, data => {\n      const {\n        streamList,\n        streamId\n      } = this.state;\n      this.setState({\n        streamList: [...streamList, data.streamId]\n      });\n\n      if (streamId !== data.streamId) {\n        const player = document.createElement('video');\n        const container = document.getElementById('group-video-container');\n        player.setAttribute('id', data.streamId);\n        player.setAttribute('class', 'video-js');\n        player.setAttribute('autoplay', 'autoplay');\n        container.append(player);\n        this.players[`player${data.streamId}`] = videojs(data.streamId, {\n          // height: 145,\n          width: container.offsetWidth / 4,\n          muted: data.streamId === streamId,\n          liveui: true\n        }, () => this.onReadyCallback(data.streamId));\n      }\n    });\n    Router.events.on('routeChangeStart', this.onbeforeunload.bind(this));\n    window.addEventListener('beforeunload', this.onbeforeunload.bind(this));\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      processing\n    } = this.props;\n\n    if (prevProps.processing !== processing) {\n      this.handleLoading(processing);\n    }\n  }\n\n  handleLoading(v) {\n    this.setState({\n      loading: v\n    });\n  }\n\n  async onHandlePrivateStream(info) {\n    const {\n      webRTCAdaptor,\n      settings\n    } = this.props;\n    const {\n      sessionId,\n      conversationId,\n      streamId\n    } = this.state;\n\n    if (info === 'initialized') {\n      const token = await streamService.getPublishToken({\n        streamId,\n        settings\n      });\n      webRTCAdaptor.publish(streamId, token);\n    } else if (info === 'publish_started') {\n      this.socket.emit('private-stream/join', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n      this.setState({\n        loading: false\n      });\n    } else if (info === 'publish_finished') {\n      this.socket.emit('private-stream/leave', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n      this.setState({\n        loading: false\n      });\n    }\n  }\n\n  onbeforeunload() {\n    this.leaveStream();\n  }\n\n  async onReadyCallback(streamId) {\n    try {\n      const {\n        settings,\n        configs\n      } = this.props;\n      const appName = configs.appName || settings.AntMediaAppname;\n      const src = await streamService.getLiveStreamOrVodURL({\n        appName,\n        settings,\n        streamId\n      });\n\n      if (!src) {\n        return;\n      }\n\n      this.players[`player${streamId}`].on('click', () => this.subscribeHLS(streamId));\n      this.players[`player${streamId}`].addClass('vjs-waiting');\n      this.players[`player${streamId}`].on('ended', () => this.ended(streamId));\n      this.players[`player${streamId}`].on('error', () => this.ended(streamId));\n      setTimeout(() => {\n        if (!this.players[`player${streamId}`]) return;\n        this.players[`player${streamId}`].src({\n          type: 'application/x-mpegURL',\n          src\n        });\n        this.players[`player${streamId}`].play();\n      }, 10 * 1000);\n    } catch (err) {\n      const error = await Promise.resolve(err);\n      message.error(getResponseError(error));\n    }\n  }\n\n  async subscribeHLS(streamId) {\n    try {\n      const {\n        settings,\n        configs\n      } = this.props;\n      const appName = configs.appName || settings.AntMediaAppname;\n      this.getLiveStreamOrVodURLInterval[streamId] && clearInterval(this.getLiveStreamOrVodURLInterval[streamId]);\n      const src = await streamService.getLiveStreamOrVodURL({\n        appName,\n        settings,\n        streamId\n      });\n\n      if (!src) {\n        return;\n      }\n\n      let video = document.querySelector('#main-group-video');\n\n      if (!video) {\n        video = document.createElement('video');\n        video.setAttribute('id', 'main-group-video');\n        video.setAttribute('class', 'video-js');\n        video.setAttribute('autoplay', 'autoplay');\n        video.setAttribute('mute', 'mute');\n        document.querySelector('.stream-group').prepend(video);\n      }\n\n      if (!window['mainPlayer']) {\n        window['mainPlayer'] = videojs('main-group-video', {\n          muted: true,\n          liveui: true,\n          controls: true\n        });\n        window['mainPlayer'].on('ended', () => window['mainPlayer'].reset());\n      }\n\n      setTimeout(() => {\n        if (!window['mainPlayer']) return;\n        window['mainPlayer'].src({\n          type: 'application/x-mpegURL',\n          src\n        });\n        window['mainPlayer'].play();\n      }, 1000);\n    } catch (err) {\n      const error = await Promise.resolve(err);\n      message.error(getResponseError(error));\n    }\n  }\n\n  start(sessionId, conversationId) {\n    this.setState({\n      sessionId,\n      conversationId\n    });\n  }\n\n  leaveStream() {\n    const {\n      publish_started\n    } = this.props;\n    const {\n      sessionId,\n      conversationId,\n      streamId\n    } = this.state;\n    Object.keys(this.getLiveStreamOrVodURLInterval).forEach(id => {\n      clearInterval(this.getLiveStreamOrVodURLInterval[id]);\n      delete this.getLiveStreamOrVodURLInterval[id];\n    });\n    this.socket.off(JOINED_THE_ROOM);\n    this.socket.off(STREAM_JOINED);\n    this.socket.off(STREAM_LEAVED);\n\n    if (publish_started) {\n      this.socket.emit('private-stream/leave', {\n        conversationId,\n        streamId,\n        sessionId\n      });\n    }\n  }\n\n  async ended(streamId) {\n    const {\n      settings\n    } = this.props;\n    const src = await streamService.getLiveStreamOrVodURL({\n      streamId,\n      settings,\n      appName: settings.AntMediaAppname\n    });\n\n    if (src) {\n      this.getLiveStreamOrVodURLInterval[streamId] = setInterval(() => {\n        fetch(src, {\n          method: 'GET'\n        }).then(() => {\n          this.players[`player${streamId}`].src({\n            type: 'application/x-mpegURL',\n            src\n          });\n          this.players[`player${streamId}`].play();\n          this.getLiveStreamOrVodURLInterval[streamId] && clearInterval(this.getLiveStreamOrVodURLInterval[streamId]);\n        });\n      }, 5000);\n    }\n  }\n\n  leave() {\n    if (false) {\n      window.location.reload();\n    }\n  }\n\n  stop() {\n    const {\n      leaveSession\n    } = this.props;\n    leaveSession();\n  }\n\n  render() {\n    const {\n      onClick,\n      btnText,\n      initialized\n    } = this.props;\n    const {\n      loading\n    } = this.state;\n    return __jsx(React.Fragment, null, !initialized ? __jsx(Button, {\n      type: \"primary\",\n      onClick: () => onClick(),\n      loading: loading,\n      block: true\n    }, btnText || 'Start Streaming') : __jsx(Button, {\n      type: \"primary\",\n      onClick: this.leave.bind(this),\n      block: true,\n      disabled: loading\n    }, \"Stop Streaming\"), __jsx(\"div\", {\n      style: {\n        position: 'relative'\n      },\n      className: \"stream-group\"\n    }, __jsx(\"div\", {\n      id: \"group-video-container\"\n    }, __jsx(\"video\", {\n      id: \"localVideoId\" // height=\"145px\"\n      ,\n      width: \"25%\",\n      autoPlay: true,\n      playsInline: true\n    }))));\n  }\n\n}\n\nGroupStreamingContainer.contextType = SocketContext;\nexport default withAntmedia(GroupStreamingContainer);","map":null,"metadata":{},"sourceType":"module"}